//===----------------------------------------------------------------------===//
//
// Copyright 2021-2021 The PolyAIE Authors.
//
//===----------------------------------------------------------------------===//

#include "mlir/Dialect/SCF/SCF.h"
#include "mlir/Dialect/Vector/VectorOps.h"
#include "mlir/Transforms/GreedyPatternRewriteDriver.h"
#include "polyaie/Transforms/Passes.h"

using namespace mlir;
using namespace polyaie;
using namespace memrefext;
using namespace xilinx::AIE;

namespace {
struct Postprocess : public polyaie::PostprocessBase<Postprocess> {
  void runOnOperation() override;
};
} // namespace

void Postprocess::runOnOperation() {
  auto mod = getOperation();
  auto b = OpBuilder(mod);
  auto loc = b.getUnknownLoc();

  // Try to convert vector.transfer_read/write operation with permutation maps
  // to memref.load and vector.broadcast.
  RewritePatternSet patterns(mod.getContext());
  vector::populateVectorTransferLoweringPatterns(patterns);
  (void)applyPatternsAndFoldGreedily(mod, std::move(patterns));

  // Remove all redundant operations, including the temporary operations
  // generated by PolyAIE or MLIR-AIE and operations that are converted.
  SmallVector<Operation *, 16> opsToErase;
  for (auto &op : llvm::make_early_inc_range(mod.getBody()->getOperations())) {
    if (auto constant = dyn_cast<ConstantOp>(op)) {
      // Localize constant operation to the usage block.
      for (auto &use : llvm::make_early_inc_range(constant->getUses())) {
        b.setInsertionPoint(use.getOwner());
        auto localConstant = cast<ConstantOp>(b.clone(*constant));
        use.set(localConstant.getResult());
      }
      constant.erase();

    } else if (auto switchBox = dyn_cast<SwitchboxOp>(op)) {
      // Remove empty switch boxes.
      if (&switchBox.getBody()->front() ==
          switchBox.getBody()->getTerminator()) {
        switchBox->dropAllUses();
        switchBox->erase();
      }
    } else if (auto lock = dyn_cast<LockOp>(op)) {
      // Remove locks that all users share the same parent operation.
      // TODO: Verify whether this is safe.
      auto parent = lock->user_begin()->getParentOp();
      if (llvm::all_of(lock->getUsers(), [&](Operation *user) {
            return user->getParentOp() == parent;
          })) {
        for (auto user : lock->getUsers())
          user->erase();
        lock->erase();
      }
    } else if (isa<CallOp, FuncOp, LoadBufferOp, StoreBufferOp, TokenOp, WireOp,
                   PLIOOp, ShimMuxOp>(op)) {
      op.dropAllUses();
      op.erase();
    }
  }

  // Traverse all tile operations in the IR.
  for (auto tile : llvm::make_early_inc_range(mod.getOps<TileOp>())) {
    if (tile.result().use_empty()) {
      // Remove unused TileOp.
      tile.erase();

    } else if (auto core = tile.getCoreOp()) {
      // Iterate the body of each AIE for N times, where N is loaded from an
      // index-typed local buffer.
      b.setInsertionPointAfter(tile);
      auto iterNumBuf =
          b.create<BufferOp>(loc, MemRefType::get({}, b.getI32Type()), tile);
      iterNumBuf->setAttr("polyaie.iter_num_buf", b.getUnitAttr());

      // Create a loop iterating for N times.
      b.setInsertionPointToStart(&core.body().front());
      auto one = b.create<ConstantOp>(loc, b.getIndexAttr(1));
      auto zero = b.create<ConstantOp>(loc, b.getIndexAttr(0));
      auto iterNum = b.create<IndexCastOp>(
          loc, b.create<memref::LoadOp>(loc, iterNumBuf), b.getIndexType());
      auto loop = b.create<scf::ForOp>(loc, zero, iterNum, one);

      // Inline all operations except the terminator in the original block into
      // the loop.
      auto &loopOps = loop.getBody()->getOperations();
      auto &blockOps = core.body().front().getOperations();
      loopOps.splice(loopOps.begin(), blockOps, std::next(blockOps.begin(), 5),
                     std::prev(blockOps.end()));
    }
  }

  // Create symbol name for all BufferOp and create lock releases to indicate
  // the completion of the whole program.
  unsigned bufIdx = 0;
  for (auto &op : mod.getBody()->getOperations()) {
    if (auto buf = dyn_cast<BufferOp>(op)) {
      auto bufName = "buf" + std::to_string(bufIdx++);
      buf->setAttr("sym_name", b.getStringAttr(bufName));

    } else if (auto store = dyn_cast<memrefext::MemCpyOp>(op)) {
      // // TODO: A temporary solution.
      // if (auto buf = store.source().getDefiningOp<BufferOp>()) {
      //   auto tile = buf.getTileOp();
      //   auto &coreBlock = tile.getCoreOp().body().front();

      //   b.setInsertionPointAfter(tile);
      //   auto lock = b.create<LockOp>(loc, tile, 15);
      //   b.setInsertionPoint(coreBlock.getTerminator());
      //   b.create<UseLockOp>(loc, lock, 1, LockAction::Release, 0);
      // }
    }
  }
}

std::unique_ptr<Pass> polyaie::createPostprocessPass() {
  return std::make_unique<Postprocess>();
}
