//===----------------------------------------------------------------------===//
//
// Copyright 2021-2021 The PolyAIE Authors.
//
//===----------------------------------------------------------------------===//

#include "polyaie/Transforms/Passes.h"

using namespace mlir;
using namespace polyaie;
using namespace memrefext;
using namespace xilinx::AIE;

namespace {
struct Postprocess : public polyaie::PostprocessBase<Postprocess> {
  void runOnOperation() override;
};
} // namespace

void Postprocess::runOnOperation() {
  auto mod = getOperation();
  auto b = OpBuilder(mod);
  auto loc = b.getUnknownLoc();

  // Remove all redundant operations, including the temporary operations
  // generated by PolyAIE or MLIR-AIE and operations that are converted.
  for (auto &op : llvm::make_early_inc_range(mod.getBody()->getOperations())) {
    if (auto constant = dyn_cast<ConstantOp>(op)) {
      // Localize constant operation to the usage block.
      for (auto &use : llvm::make_early_inc_range(constant->getUses())) {
        b.setInsertionPoint(use.getOwner());
        auto localConstant = cast<ConstantOp>(b.clone(*constant));
        use.set(localConstant.getResult());
      }
      constant.erase();

    } else if (auto switchBox = dyn_cast<SwitchboxOp>(op)) {
      if (&switchBox.getBody()->front() ==
          switchBox.getBody()->getTerminator()) {
        switchBox->dropAllUses();
        switchBox->erase();
      }
    } else if (isa<CallOp, FuncOp, LoadBufferOp, StoreBufferOp, TokenOp, WireOp,
                   PLIOOp, ShimMuxOp>(op)) {
      op.dropAllUses();
      op.erase();
    }
  }

  // Remove unused TileOp.
  for (auto tile : llvm::make_early_inc_range(mod.getOps<TileOp>())) {
    if (tile.result().use_empty())
      tile.erase();
    else if (auto core = tile.getCoreOp()) {
      b.setInsertionPointAfter(tile);
      auto lock = b.create<LockOp>(loc, tile, 15);

      b.setInsertionPoint(core.body().front().getTerminator());
      b.create<UseLockOp>(loc, lock, 1, LockAction::Release, 0);
    }
  }
}

std::unique_ptr<Pass> polyaie::createPostprocessPass() {
  return std::make_unique<Postprocess>();
}
