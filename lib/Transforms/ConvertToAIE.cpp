//===----------------------------------------------------------------------===//
//
// Copyright 2021-2021 The PolyAIE Authors.
//
//===----------------------------------------------------------------------===//

#include "mlir/Dialect/Affine/Passes.h"
#include "mlir/Pass/PassManager.h"
#include "mlir/Transforms/Passes.h"
#include "polyaie/Transforms/Passes.h"

using namespace mlir;
using namespace polyaie;
using namespace memrefext;
using namespace xilinx::AIE;

namespace {
struct ConvertToAIE : public polyaie::ConvertToAIEBase<ConvertToAIE> {
  void runOnOperation() override;
};
} // namespace

void ConvertToAIE::runOnOperation() {
  auto mod = getOperation();
  auto b = OpBuilder(mod);

  unsigned bufIdx = 0;
  for (auto alloc : mod.getOps<memref::AllocOp>()) {
    for (auto user : alloc.getResult().getUsers()) {
      // Create a new logical token for each tile of memory.
      b.setInsertionPoint(user);
      auto token = b.create<TokenOp>(user->getLoc(), 0);
      auto tokenName = "token" + std::to_string(bufIdx++);
      token->setAttr("sym_name", b.getStringAttr(tokenName));

      // Create a worklist where the first item is the buffer generated by the
      // LoadBufferOp.
      auto loadOp = dyn_cast<LoadBufferOp>(user);
      if (!loadOp)
        continue; // Ignore StoreBufferOp.
      SmallVector<Value, 32> worklist({loadOp.buffer()});

      // Propogate the buffer in the whole program to generate the token aquire
      // and release sequence.
      unsigned tokenVal = 1;
      while (!worklist.empty()) {
        auto buf = worklist.pop_back_val();

        int64_t bufTokenVal = 0;
        if (auto copyOp = buf.getDefiningOp<CopyBufferOp>())
          bufTokenVal =
              copyOp->getAttrOfType<IntegerAttr>("aie.token_release").getInt();

        for (auto &use : buf.getUses()) {
          auto call = dyn_cast<CallOp>(use.getOwner());
          if (!call)
            continue; // Ignore StoreBufferOp.
          auto func = mod.lookupSymbol<FuncOp>(call.callee());

          // Acquire the current token in the function.
          b.setInsertionPointToStart(&func.front());
          b.create<UseTokenOp>(call.getLoc(), tokenName, bufTokenVal,
                               LockAction::Acquire);

          // Find the result buffer if it exists.
          auto terminator = func.front().getTerminator();
          auto argPtr = llvm::find_if(terminator->getOperands(), [&](Value v) {
            return v == func.getArgument(use.getOperandNumber());
          });

          if (argPtr != terminator->getOperands().end()) {
            // Release the current token in the function.
            auto funcTokenVal = tokenVal++;
            b.setInsertionPoint(terminator);
            b.create<UseTokenOp>(call.getLoc(), tokenName, funcTokenVal,
                                 LockAction::Release);

            // Create CopyBufferOp for each result buffer.
            auto resultBuf =
                call.getResult(argPtr - terminator->getOperands().begin());
            b.setInsertionPointAfter(call);
            auto copyOp = b.create<CopyBufferOp>(
                b.getUnknownLoc(), resultBuf.getType(), resultBuf);
            resultBuf.replaceAllUsesWith(copyOp.target());

            // Set token acquire and release for the CopyBufferOp.
            copyOp->setAttr("aie.token_acquire",
                            b.getI64IntegerAttr(funcTokenVal));
            copyOp->setAttr("aie.token_release",
                            b.getI64IntegerAttr(tokenVal++));

            // Push back the result buffer into the worklist.
            worklist.push_back(copyOp.target());
          }
        }
      }

      // Working here...
    }
  }

  PassManager pm(mod.getContext(), "module");
  pm.addPass(createAIECreateCoresPass());
  if (failed(pm.run(mod))) {
    emitError(mod.getLoc(), "failed to implement on AIE array");
    return signalPassFailure();
  }
}

std::unique_ptr<Pass> polyaie::createConvertToAIEPass() {
  return std::make_unique<ConvertToAIE>();
}
