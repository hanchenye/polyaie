//===----------------------------------------------------------------------===//
//
// Copyright 2021-2021 The PolyAIE Authors.
//
//===----------------------------------------------------------------------===//

#include "mlir/Dialect/Affine/Passes.h"
#include "mlir/Pass/PassManager.h"
#include "mlir/Transforms/Passes.h"
#include "polyaie/Transforms/Passes.h"

using namespace mlir;
using namespace polyaie;
using namespace memrefext;
using namespace xilinx::AIE;

namespace {
struct ConvertToAIE : public polyaie::ConvertToAIEBase<ConvertToAIE> {
  void runOnOperation() override;
};
} // namespace

static void createMemBlocks(OpBuilder &b, Location loc, Block *dmaBlock,
                            Block *bdBlock, Block *endBlock, Value buf,
                            StringRef tokenName, int64_t tokenAcquire,
                            int64_t tokenRelease, DMAChan channel) {
  auto insertPoint = b.saveInsertionPoint();

  // Create DMA start block.
  b.setInsertionPointToStart(dmaBlock);
  b.create<DMAStartOp>(loc, channel, bdBlock, endBlock);

  // Create DMA descripter block.
  b.setInsertionPointToStart(bdBlock);
  b.create<UseTokenOp>(loc, tokenName, tokenAcquire, LockAction::Acquire);
  b.create<DMABDOp>(loc, buf, /*offset=*/0,
                    buf.getType().cast<MemRefType>().getNumElements(), 0);
  b.create<UseTokenOp>(loc, tokenName, tokenRelease, LockAction::Release);
  b.create<BranchOp>(loc, bdBlock);

  // Create DMA end block.
  if (endBlock->empty()) {
    b.setInsertionPointToStart(endBlock);
    b.create<xilinx::AIE::EndOp>(loc);
  }

  b.restoreInsertionPoint(insertPoint);
}

static void createOrUpdateMemOp(OpBuilder &b, CopyBufferOp copyOp, TileOp tile,
                                Value buf, DMAChan channel) {
  // Extract token information.
  auto tokenName = copyOp->getAttrOfType<StringAttr>("aie.token").getValue();
  auto tokenAcquire =
      copyOp->getAttrOfType<IntegerAttr>("aie.token_acquire").getInt();
  auto tokenRelease =
      copyOp->getAttrOfType<IntegerAttr>("aie.token_release").getInt();

  if (auto aieMem = tile.getMemOp()) {
    auto &endBlock = aieMem.body().back();
    auto &predDmaBlock = *std::prev(aieMem.body().end(), 3);

    auto insertPoint = b.saveInsertionPoint();
    auto dmaBlock = b.createBlock(&endBlock);
    auto bdBlock = b.createBlock(&endBlock);
    b.restoreInsertionPoint(insertPoint);

    auto predDma = cast<DMAStartOp>(&predDmaBlock.front());
    predDma.setSuccessor(dmaBlock, /*index=*/1);

    createMemBlocks(b, copyOp.getLoc(), dmaBlock, bdBlock, &endBlock, buf,
                    tokenName, tokenAcquire, tokenRelease, channel);
  } else {
    auto newAieMem = b.create<MemOp>(copyOp.getLoc(), tile);

    auto &dmaBlock = newAieMem.body().emplaceBlock();
    auto &bdBlock = newAieMem.body().emplaceBlock();
    auto &endBlock = newAieMem.body().emplaceBlock();

    createMemBlocks(b, copyOp.getLoc(), &dmaBlock, &bdBlock, &endBlock, buf,
                    tokenName, tokenAcquire, tokenRelease, channel);
  }
}

void ConvertToAIE::runOnOperation() {
  auto mod = getOperation();
  auto b = OpBuilder(mod);

  // Generate TokenOp, CopyBufferOp, and token release and acquires.
  unsigned tokenIdx = 0;
  for (auto alloc : mod.getOps<memref::AllocOp>()) {
    for (auto user : alloc.getResult().getUsers()) {
      // Create a worklist where the first item is the buffer generated by the
      // LoadBufferOp.
      auto loadOp = dyn_cast<LoadBufferOp>(user);
      if (!loadOp)
        continue; // Ignore StoreBufferOp.
      SmallVector<Value, 32> worklist({loadOp.buffer()});

      // Create a new logical token for each tile of memory.
      b.setInsertionPoint(user);
      auto token = b.create<TokenOp>(user->getLoc(), 0);
      auto tokenName = "token" + std::to_string(tokenIdx++);
      auto tokenNameAttr = b.getStringAttr(tokenName);
      token->setAttr("sym_name", tokenNameAttr);

      // Propogate the buffer in the whole program to generate the token aquire
      // and release sequence.
      unsigned tokenVal = 1;
      while (!worklist.empty()) {
        auto buf = worklist.pop_back_val();

        int64_t bufTokenVal = 0;
        if (auto copyOp = buf.getDefiningOp<CopyBufferOp>())
          bufTokenVal =
              copyOp->getAttrOfType<IntegerAttr>("aie.token_release").getInt();

        for (auto &use : buf.getUses()) {
          auto call = dyn_cast<CallOp>(use.getOwner());
          if (!call)
            continue; // Ignore StoreBufferOp.
          auto func = mod.lookupSymbol<FuncOp>(call.callee());

          // Acquire the current token in the function.
          b.setInsertionPointToStart(&func.front());
          b.create<UseTokenOp>(call.getLoc(), tokenName, bufTokenVal,
                               LockAction::Acquire);

          // Release the current token in the function.
          auto terminator = func.front().getTerminator();
          auto funcTokenVal = tokenVal++;
          b.setInsertionPoint(terminator);
          b.create<UseTokenOp>(call.getLoc(), tokenName, funcTokenVal,
                               LockAction::Release);

          // Find the result buffer if it exists. Also, we ignore the result
          // buffer that is only used in buffer storing.
          auto argPtr = llvm::find_if(terminator->getOperands(), [&](Value v) {
            return v == func.getArgument(use.getOperandNumber());
          });
          if (argPtr == terminator->getOperands().end())
            continue;

          auto resultBuf =
              call.getResult(argPtr - terminator->getOperands().begin());
          if (resultBuf.hasOneUse() &&
              isa<StoreBufferOp>(*resultBuf.getUsers().begin()))
            continue;

          // Create CopyBufferOp for each result buffer.
          b.setInsertionPointAfter(call);
          auto copyOp = b.create<CopyBufferOp>(b.getUnknownLoc(),
                                               resultBuf.getType(), resultBuf);
          resultBuf.replaceUsesWithIf(copyOp.target(), [&](OpOperand &operand) {
            return isa<CallOp>(operand.getOwner());
          });

          // Set token acquire and release for the CopyBufferOp.
          copyOp->setAttr("aie.token", tokenNameAttr);
          copyOp->setAttr("aie.token_acquire",
                          b.getI64IntegerAttr(funcTokenVal));
          copyOp->setAttr("aie.token_release", b.getI64IntegerAttr(tokenVal++));

          // Push back the result buffer into the worklist.
          worklist.push_back(copyOp.target());
        }
      }
    }
  }

  // Convert function CallOps to TileOps and CoreOps. Generate BufferOps,
  // MemOps, and FlowOps, and lower LoadBufferOp and StoreBufferOp to MemCpyOp.
  unsigned bufIdx = 0;
  DenseMap<Operation *, TileOp> tileMap;
  TileOp lastTile;
  for (auto call : mod.getOps<CallOp>()) {
    auto func = mod.lookupSymbol<FuncOp>(call.callee());
    auto returnOp = cast<ReturnOp>(func.front().getTerminator());
    b.setInsertionPoint(call);

    // Generate TileOp based on the placement results.
    auto aieTile = b.create<TileOp>(
        call.getLoc(), call->getAttrOfType<IntegerAttr>("aie.col").getInt(),
        call->getAttrOfType<IntegerAttr>("aie.row").getInt());
    tileMap[call] = aieTile;
    lastTile = aieTile;

    // Generate a BufferOp for each argument of the function. Lower LoadBufferOp
    // and CopyBufferOp associated with each argument.
    unsigned channelIdx = 0;
    for (auto arg : func.getArguments()) {
      auto aieBuf = b.create<BufferOp>(call.getLoc(), arg.getType(), aieTile);
      auto bufName = "buf" + std::to_string(bufIdx++);
      aieBuf->setAttr("sym_name", b.getStringAttr(bufName));
      arg.replaceAllUsesExcept(aieBuf, SmallPtrSet<Operation *, 2>({returnOp}));

      auto buf = call.getOperand(arg.getArgNumber());
      auto bufType = buf.getType().cast<MemRefType>();
      if (auto loadOp = buf.getDefiningOp<LoadBufferOp>()) {
        // Lower LoadBufferOp to general MemCpyOp.
        auto rank = std::max(bufType.getRank(), (int64_t)1);
        b.create<memrefext::MemCpyOp>(
            loadOp.getLoc(), b.getI64ArrayAttr(SmallVector<int64_t>(rank, 0)),
            loadOp.offsets(), loadOp.lengths(), aieBuf, loadOp.memory());

      } else if (auto copyOp = buf.getDefiningOp<CopyBufferOp>()) {
        // TODO: Handle direct memory access.
        // TODO: Handle more than 2 input channels.
        if (channelIdx > 1) {
          copyOp.emitOpError("each AIE only has two S2MM channels");
          return signalPassFailure();
        }

        // Create FlowOp connecting the source tile and current tile.
        // TODO: Handle multi-results call operation.
        auto sourceTile = tileMap[copyOp.source().getDefiningOp<CallOp>()];
        b.create<FlowOp>(copyOp.getLoc(), sourceTile, WireBundle::DMA, 0,
                         aieTile, WireBundle::DMA, channelIdx);

        // Create or update MemOp for DMA descripters.
        createOrUpdateMemOp(b, copyOp, aieTile, aieBuf,
                            channelIdx ? DMAChan::S2MM1 : DMAChan::S2MM0);
        ++channelIdx;

      } else {
        buf.getDefiningOp()->emitOpError(
            "should only be used by LoadBufferOp or CopyBufferOp");
        return signalPassFailure();
      }

      // Replace the original buffer with AIE buffer.
      call.setOperand(arg.getArgNumber(), aieBuf);
    }

    channelIdx = 0;
    for (auto result : call.getResults()) {
      auto arg = returnOp.getOperand(result.getResultNumber());
      auto aieBuf = call.getOperand(arg.cast<BlockArgument>().getArgNumber());
      auto bufType = aieBuf.getType().cast<MemRefType>();

      for (auto user : result.getUsers()) {
        if (auto storeOp = dyn_cast<StoreBufferOp>(user)) {
          // Lower StoreBufferOp to general MemCpyOp.
          auto rank = std::max(bufType.getRank(), (int64_t)1);
          b.create<memrefext::MemCpyOp>(
              storeOp.getLoc(), storeOp.offsets(),
              b.getI64ArrayAttr(SmallVector<int64_t>(rank, 0)),
              storeOp.lengths(), storeOp.memory(), aieBuf);

        } else if (auto copyOp = dyn_cast<CopyBufferOp>(user)) {
          // TODO: Handle multi-results call operation.
          if (channelIdx > 0) {
            copyOp.emitOpError("each AIE only has two MM2S channels");
            return signalPassFailure();
          }

          // Create or update MemOp for DMA descripters.
          createOrUpdateMemOp(b, copyOp, aieTile, aieBuf, DMAChan::MM2S0);
          ++channelIdx;

        } else {
          user->emitOpError(
              "should only be used by StoreBufferOp or CopyBufferOp");
          return signalPassFailure();
        }
      }
    }

    // Generate a CoreOp and inline the contents of the function.
    auto aieCore = b.create<CoreOp>(call.getLoc(), aieTile);
    auto &coreBlock = aieCore.body().emplaceBlock();

    auto &funcOps = func.front().getOperations();
    auto &coreOps = coreBlock.getOperations();
    coreOps.splice(coreOps.begin(), funcOps, funcOps.begin(),
                   std::prev(funcOps.end()));

    b.setInsertionPointToEnd(&coreBlock);
    b.create<xilinx::AIE::EndOp>(call.getLoc());
  }

  PassManager pm(mod.getContext(), "module");
  pm.addPass(createAIEAssignBufferAddressesPass());
  pm.addPass(createAIEPathfinderPass());
  pm.addPass(createAIECreateLocksPass());
  if (failed(pm.run(mod))) {
    emitError(mod.getLoc(), "failed to implement on AIE array");
    return signalPassFailure();
  }

  // Remove all redundant operations that are already converted.
  for (auto &op : llvm::make_early_inc_range(mod.getBody()->getOperations()))
    if (isa<LoadBufferOp, StoreBufferOp, CopyBufferOp, TokenOp, WireOp, PLIOOp,
            ShimMuxOp, CallOp, FuncOp>(op)) {
      op.dropAllUses();
      op.erase();
    }

  // Localize constants.
  for (auto constant : llvm::make_early_inc_range(mod.getOps<ConstantOp>())) {
    for (auto &use : llvm::make_early_inc_range(constant->getUses())) {
      b.setInsertionPoint(use.getOwner());
      auto localConstant = dyn_cast<ConstantOp>(b.clone(*constant));
      use.set(localConstant.getResult());
    }
    constant.erase();
  }

  // Create a lock release in the last tile's CoreOp to indicate the completion
  // of the program.
  // TODO: Make this more rebust.
  b.setInsertionPointAfter(lastTile);
  auto finalLock = b.create<LockOp>(lastTile.getLoc(), lastTile, 15);

  auto lastCore = lastTile.getCoreOp();
  b.setInsertionPoint(lastCore.body().front().getTerminator());
  b.create<UseLockOp>(lastTile.getLoc(), finalLock, 1, LockAction::Release, 0);
}

std::unique_ptr<Pass> polyaie::createConvertToAIEPass() {
  return std::make_unique<ConvertToAIE>();
}
